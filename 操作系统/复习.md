# 输入输出子系统



## 输入输出设备概述

### 概述

输入输出设备：连接CPU的所有设备，称为输入输出设备，简称设备(外设)

和CPU连接方式：控制器 端口 总线

### 	设备分类

1. 输入设备和输出设备；
2. 高速设备和低速设备；
3. 字符设备和块设备；
4. 随机访问和顺序访问设备；
5. 互斥使用和并发使用的设备

### 控制方式

- 轮询：消耗CPU时间，减少CPU切换，适合短时输入输出
- 中断：上下文切换需要消耗CPU时间
- DMA：可以减少中断次数

### 输入输出系统架构

![image-20210811011033913](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011033913.png)

### 设备地址和名字

地址：独立编址方式 ，统一编址方式

名字：逻辑设备-->操作系统-->物理设备



## 硬盘

### 物理结构

- 盘头 磁道  读写磁头 扇区(存储数据) 电机

- 格式化
  - 低级格式化 ：低级格式化后减少：前导码，间隙，ECC
  - 高级格式化
- 物理地址

### 逻辑结构

- 盘块(簇)：一组相邻的扇区
- 逻辑空间
  - 线性的、以块为单位的存储空间
  - ![image-20210811011142166](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011142166.png)

### 访问时间

寻道，旋转延迟，传输

影响因素： IO次数，  IO数据传输量

### 磁盘调度算法

磁头应该从当前柱面朝哪个柱面移动	

当前柱面：50，请求序列：90，10，80，20

1. FCFS

![image-20210811011215954](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011215954.png)

2. 最短寻道时间优先(SSTF)(存在饥饿)

   原因：用户请求集中在离当前磁道较近的位置

   ![image-20210811011244951](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011244951.png)

3. SCAN

   ![image-20210621172136174](D:\My_University\笔记\操作系统\复习.assets\image-20210621172136174.png)

4. C-SCAN

   ![image-20210621172254979](D:\My_University\笔记\操作系统\复习.assets\image-20210621172254979.png)

5. LOOK 与C-LOOK 是SCAN的增强，不移动到磁盘的一端

## 时钟和定时器

### 基本功能

![image-20210811011358497](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011358497.png)

### 可编程计数器

晶体振荡器 计数器 保存寄存器

### 设置时钟

1. 电池时钟：电池供电的时钟，关机后依然运行，备份时钟

2. 系统时钟，内存变量：从电池时钟读时间，或用户输入，作为初始时间每次时钟中断，修改系统时钟系统所有行为是以系统时钟为基准的

- 注：时钟不同，以系统时钟为准

### 时钟驱动程序

1. 修改系统时钟
2. 实现轮转法CPU调度
3. 为进程定制自己的定时器
4. 记账，统计

### 软定时器

时钟中断代价较大，一般中断十几ms产生一次，而在某些高性能网络传输，12us接收一次，唤醒接收线程，采用–轮询：可能存在相当长的等待时间，而中断–频率太高，代价太大

实现：内核返回用户态(每次系统调用都会产生)，判断软定时器是否到期

频率较高，但可能会有延迟，一般采用软硬结合的方式

## 驱动程序



### 概念

- 直接控制设备的程序，直接读写控制器中的寄存器

- 主设备号和次设备号(一类和具体)

### 设备依赖性

1. 直接控制设备，与设备特性紧密相关

2. 更换设备需要更换驱动程序

- 目标：使内核的其他部分是设备独立的，内核IO子系统

### 结构和功能

启动设备(启动部分)：被内核IO子系统调用，启动设备

中断服务(服务例程)：被中断处理程序调用

处理来自设备的中断事件：初始化，确定中断号，注册服务例程

### 在I/O系统中地位

![image-20210811011423885](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011423885.png)

1. 驱动程序与内核IO子系统

   被调用，执行IO启动操作，返回结果

​       可以调用内核，如阻塞、唤醒线程

2. 驱动程序与中断处理程序

​       被调用，执行设备服务例程

3. 驱动程序与设备

​       发送命令；检测状态；通过中断机制响应设备事件



## 中断处理程序

### 处理机制

1. 操作系统是中断驱动的(异常、陷入、外部中断）
2. 设备的中断处理过程由中断信号触发
3. 中断信号来自中断控制器(中断控制器：接收多个中断源的请求，选择某个请求送给CPU)

### 中断处理程序与中断服务例程

设备数量多于中断号,一组设备共用一个引脚，一个中断号，触发同一个中断处理程序

中断处理程序查询中断号，调用服务例程检查自己负责的设备是否发出中断，不是的话返回，中断服务程序就会调用下一个终端服务例程

### 中断处理程序步骤

![image-20210811011447145](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011447145.png)

- 注：保护现场1 ，第三章讲过：保护断点关中断等

## 内核I/O子系统

不依赖具体设备，处理设备共性问题

### 缓冲区

临时的存储区，缓和通信双方(进、出)处理上的差异性(处理速度，处理单元)

缓冲区越大，其能力越强

类型：单，双，环形

### 缓冲池

多个缓冲区的集合。程序需要时申请，用完后释放回来

特点：内核各模块共享，集中管理，提高内存利用率

### 高速缓存(cache)

区别：

1. 高速缓存为了提高效率，缓冲区用于通信双方数据的交换
2. 高速缓存中的内容是另一个存储器内容的备份，缓冲区中的数据是唯一的
3. 高速缓存，也可以同时是缓冲区

### 假脱机输入输出

![image-20210811011516110](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011516110.png)

- 守护进程：开机时启动、后台运行、无交互，直至关机
- 申请(申请不会阻塞)；读写(实际阻塞在磁盘I/O)

### 错误处理

特点：种类繁多，可以补救(非核心部件)

解决：硬件->驱动程序->内核I/O子系统->应用程序->人

### 应用程序I/O接口

![image-20210811011546331](https://gitee.com/Fantastic-Feng/picgo/raw/master/image-20210811011546331.png)

1. 阻塞：

   一般情况下，阻塞，返回结果，进程变为就绪状态不等待的情况：数据已在缓存中

2. 非阻塞

      执行输入输出操作，立刻返回

   1. 单线程情况下：读操作时，有多少数据就带回多少，启动操作后，CPU立即返回

   2. 多线程情况下：某个线程执行IO操作后，立即返回执行其他线程，原线程等待

   - 进程没有中止，不算阻塞

3. 异步

   数据立即返回，进程继续执行；I/O操作的结果有用，但不着急

非阻塞：数据读没读进来不重要，我不等 	异步：先去干别的事儿，数据来了告诉我

## I/O操作流程

以进程J调用IO函数getchar()为例

1. 应用程序层的IO操作，进程J调用IO函数getchar()，getchar()最终落实到一般的系统调用

2. 内核I/O子系统：内核检查系统调用read()的合法性，如参数、操作权限等，确定的设备是键盘，找到并调用相应的驱动程序

3. 键盘驱动程序：如果键盘输入缓冲区中有满足条件的数据，则取出字符并返回，否则，进程J阻塞，被挂到键盘的等待队列中，等待用户输入
4. 用户从键盘输入字符,产生键盘中断，CPU执行键盘中断处理程序
5. 唤醒阻塞的进程J，放入就绪队列
6. 经过一段时间之后，CPU调度程序选中进程J
7. 系统调用read()返回，getchar()返回用户程序

